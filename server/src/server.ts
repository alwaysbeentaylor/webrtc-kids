import 'dotenv/config';
import express from 'express';
import https from 'https';
import http from 'http';
import cors from 'cors';
import { Server as SocketIOServer } from 'socket.io';
import { authenticateSocket, AuthenticatedSocket } from './auth/socketAuth';
import fs from 'fs';
import path from 'path';

const app = express();

// Try to create HTTPS server, fallback to HTTP
let server: http.Server | https.Server;
const useHttps = process.env.USE_HTTPS === 'true';

if (useHttps) {
  // Look for certificate files (generated by @vitejs/plugin-basic-ssl)
  const certPath = path.join(__dirname, '../../localhost.pem');
  const keyPath = path.join(__dirname, '../../localhost-key.pem');
  
  if (fs.existsSync(certPath) && fs.existsSync(keyPath)) {
    const cert = fs.readFileSync(certPath);
    const key = fs.readFileSync(keyPath);
    server = https.createServer({ cert, key }, app);
    console.log('🔒 HTTPS server enabled');
  } else {
    console.log('⚠️ HTTPS requested but certificates not found, using HTTP');
    server = http.createServer(app);
  }
} else {
  server = http.createServer(app);
}

const PORT = Number(process.env.PORT || 4000);
const CLIENT_ORIGIN = process.env.CLIENT_ORIGIN || 'http://localhost:5173';

console.log('🚀 Starting server...');
console.log('📋 Environment variables:');
console.log('  - PORT:', PORT);
console.log('  - CLIENT_ORIGIN:', CLIENT_ORIGIN);
console.log('  - NODE_ENV:', process.env.NODE_ENV || 'development');

// Allow multiple origins for local network access (both HTTP and HTTPS)
// Also allow Vercel deployments and custom domains
const allowedOrigins = [
  CLIENT_ORIGIN,
  'http://localhost:5173',
  'https://localhost:5173',
  'http://127.0.0.1:5173',
  'https://127.0.0.1:5173',
  'http://192.168.0.166:5173',
  'https://192.168.0.166:5173',
  'http://10.150.157.142:5173',
  'https://10.150.157.142:5173',
  // Allow any local network IP (both HTTP and HTTPS)
  /^https?:\/\/192\.168\.\d+\.\d+:5173$/,
  /^https?:\/\/10\.\d+\.\d+\.\d+:5173$/,
  // Allow Vercel deployments (any .vercel.app domain)
  /^https:\/\/.*\.vercel\.app$/,
  // Allow any HTTPS origin for production (more permissive for deployment)
  /^https:\/\/.*$/,
];

app.use(cors({ 
  origin: (origin, callback) => {
    // Allow requests with no origin (like mobile apps or curl requests)
    if (!origin) {
      console.log('✅ CORS: Allowing request with no origin');
      return callback(null, true);
    }
    
    console.log('🔍 CORS: Checking origin:', origin);
    
    // Check if origin is in allowed list
    const isAllowed = allowedOrigins.some(allowed => {
      if (typeof allowed === 'string') {
        return allowed === origin;
      } else if (allowed instanceof RegExp) {
        return allowed.test(origin);
      }
      return false;
    });
    
    if (isAllowed) {
      console.log('✅ CORS: Allowing origin:', origin);
      callback(null, true);
    } else {
      console.log('⚠️ CORS: Origin not in allowed list, but allowing anyway:', origin);
      callback(null, true); // Allow anyway for development/production flexibility
    }
  },
  credentials: true
}));
app.use(express.json());

app.get('/health', (_req, res) => {
  res.json({ ok: true, service: 'signaling-server' });
});

const io = new SocketIOServer(server, {
  cors: {
    origin: (origin, callback) => {
      // Allow requests with no origin
      if (!origin) {
        console.log('✅ Socket.IO CORS: Allowing request with no origin');
        return callback(null, true);
      }
      
      console.log('🔍 Socket.IO CORS: Checking origin:', origin);
      
      // Check if origin is in allowed list
      const isAllowed = allowedOrigins.some(allowed => {
        if (typeof allowed === 'string') {
          return allowed === origin;
        } else if (allowed instanceof RegExp) {
          return allowed.test(origin);
        }
        return false;
      });
      
      if (isAllowed) {
        console.log('✅ Socket.IO CORS: Allowing origin:', origin);
        callback(null, true);
      } else {
        console.log('⚠️ Socket.IO CORS: Origin not in allowed list, but allowing anyway:', origin);
        callback(null, true); // Allow anyway for development/production flexibility
      }
    },
    methods: ['GET', 'POST'],
    credentials: true
  },
  transports: ['websocket', 'polling'] // Allow both transports
});

// Authentication middleware for socket connections
io.use(async (socket: AuthenticatedSocket, next) => {
  // FORCE LOG to console immediately - USE process.stdout to ensure it's shown
  process.stdout.write('\n\n🔍🔍🔍 ========== MIDDLEWARE CALLED ==========\n');
  process.stdout.write(`🔍 Socket ID: ${socket.id}\n`);
  process.stdout.write(`🔍 AUTH: ${JSON.stringify(socket.handshake.auth)}\n`);
  process.stdout.write(`🔍 QUERY: ${JSON.stringify(socket.handshake.query)}\n`);
  
  // Get token from anywhere - try ALL possible locations
  const auth = socket.handshake.auth;
  const query = socket.handshake.query;
  
  let token: string | undefined = undefined;
  
  // Method 1: auth.token (object property)
  if (auth && typeof auth === 'object' && auth !== null) {
    if ('token' in auth) {
      token = String((auth as any).token);
      process.stdout.write(`✅✅✅ Token from auth.token: ${token}\n`);
    }
  }
  
  // Method 2: auth as string
  if (!token && typeof auth === 'string') {
    token = auth;
    process.stdout.write(`✅✅✅ Token from auth (string): ${token}\n`);
  }
  
  // Method 3: query.token
  if (!token && query) {
    if ('token' in query) {
      const qToken = query.token;
      token = Array.isArray(qToken) ? String(qToken[0]) : String(qToken);
      process.stdout.write(`✅✅✅ Token from query.token: ${token}\n`);
    }
  }
  
  process.stdout.write(`🔐🔐🔐 FINAL TOKEN: ${token || 'UNDEFINED'}\n`);
  process.stdout.write(`🔐🔐🔐 Starts with child-token-: ${token ? token.startsWith('child-token-') : false}\n`);
  
  // CRITICAL: If it's a child token, accept IMMEDIATELY without any checks
  if (token && typeof token === 'string' && token.startsWith('child-token-')) {
    const userId = token.replace('child-token-', '').trim();
    if (userId && userId.length > 0) {
      socket.userId = userId;
      socket.userRole = 'child';
      process.stdout.write(`✅✅✅✅✅✅✅✅✅ CHILD ACCEPTED: ${socket.id}, User: ${userId}\n`);
      return next(); // Accept immediately!
    }
  }
  
  // DEV ONLY: Accept parent dev token without Firebase (for local testing), gated by env
  if (
    process.env.NODE_ENV !== 'production' &&
    process.env.DEV_FAKE_PARENT_AUTH === 'true' &&
    token && typeof token === 'string' && token.startsWith('dev-parent-token-')
  ) {
    const userId = token.replace('dev-parent-token-', '').trim();
    if (userId && userId.length > 0) {
      socket.userId = userId;
      socket.userRole = 'parent';
      process.stdout.write(`✅✅✅ DEV PARENT ACCEPTED: ${socket.id}, User: ${userId}\n`);
      return next();
    }
  }
  
  // For parents, use normal authentication
  try {
    const authenticated = await authenticateSocket(socket);
    if (authenticated) {
      process.stdout.write('✅ PARENT AUTH SUCCESS\n');
      next();
    } else {
      process.stdout.write('❌ AUTH FAILED - rejecting\n');
      next(new Error('Authentication failed'));
    }
  } catch (error) {
    process.stdout.write(`❌ AUTH EXCEPTION: ${error}\n`);
    next(new Error('Authentication failed'));
  }
});

io.on('connection', (socket: AuthenticatedSocket) => {
  console.log('✅✅✅ NEW SOCKET CONNECTION:', socket.id, 'User:', socket.userId, 'Role:', socket.userRole);
  
  // Log all rooms immediately after connection
  setTimeout(() => {
    const allRooms = Array.from(io.sockets.adapter.rooms.keys());
    console.log('📋 Rooms after connection:', allRooms);
  }, 1000);

  // Ping/pong test
  socket.on('ping', (payload) => {
    console.log('ping from authenticated client:', socket.userId, payload);
    socket.emit('pong', { at: Date.now(), userId: socket.userId });
  });

  // WebRTC signaling events (will be expanded later)
  socket.on('call:offer', (data) => {
    process.stdout.write('\n\n📞📞📞 ========== CALL OFFER RECEIVED ==========\n');
    process.stdout.write(`📞 From: ${socket.userId} (socket: ${socket.id})\n`);
    process.stdout.write(`📞 To: ${data.targetUserId}\n`);
    process.stdout.write(`📞 Has offer: ${!!data.offer}\n`);
    
    // Check if target user is in their room
    const targetRoom = `user:${data.targetUserId}`;
    const roomExists = io.sockets.adapter.rooms.has(targetRoom);
    
    process.stdout.write(`🔍 Target room: ${targetRoom}\n`);
    process.stdout.write(`🔍 Room exists: ${roomExists}\n`);
    
    // Debug: List all rooms
    const allRooms = Array.from(io.sockets.adapter.rooms.keys());
    process.stdout.write(`📋 All active rooms: ${allRooms.join(', ')}\n`);
    
    // Also check all connected sockets and their userIds
    const connectedSockets = Array.from(io.sockets.sockets.values());
    process.stdout.write(`👥 Connected sockets (${connectedSockets.length}):\n`);
    connectedSockets.forEach(s => {
      const authSocket = s as AuthenticatedSocket;
      const isInRoom = Array.from(io.sockets.adapter.socketRooms(authSocket.id) || []).includes(targetRoom);
      process.stdout.write(`  - Socket ${authSocket.id}: userId=${authSocket.userId}, inRoom=${isInRoom}\n`);
    });
    
    if (!roomExists) {
      process.stdout.write(`❌❌❌ Target user NOT in room: ${targetRoom}\n`);
      socket.emit('error', { 
        message: `Gebruiker ${data.targetUserId} is niet online of niet verbonden.` 
      });
      return;
    }
    
          // Forward offer to target user
          const offerData = {
            ...data,
            fromUserId: socket.userId,
            targetUserId: data.targetUserId
          };
          
          process.stdout.write(`📤📤📤 Forwarding offer to room: ${targetRoom}\n`);
          process.stdout.write(`📤 Sending to socket in room: ${targetRoom}\n`);
          process.stdout.write(`📤 Offer data: ${JSON.stringify({
            fromUserId: offerData.fromUserId,
            targetUserId: offerData.targetUserId,
            hasOffer: !!offerData.offer,
            offerType: offerData.offer?.type
          })}\n`);
          
          // Use io.to() instead of socket.to() to ensure it reaches the room
          io.to(targetRoom).emit('call:offer', offerData);
          
          // Also log how many sockets are in the target room
          const socketsInRoom = io.sockets.adapter.rooms.get(targetRoom);
          const socketCount = socketsInRoom ? socketsInRoom.size : 0;
          process.stdout.write(`📤 Sockets in room: ${socketCount}\n`);
          
          process.stdout.write(`✅✅✅ Call offer forwarded to: ${targetRoom}\n\n`);
  });

  socket.on('call:answer', (data) => {
    process.stdout.write('\n\n📞📞📞 ========== CALL ANSWER RECEIVED ==========\n');
    process.stdout.write(`📞 From: ${socket.userId} (socket: ${socket.id})\n`);
    process.stdout.write(`📞 To: ${data.targetUserId}\n`);
    process.stdout.write(`📞 Has answer: ${!!data.answer}\n`);
    
    const targetRoom = `user:${data.targetUserId}`;
    process.stdout.write(`📤 Forwarding answer to room: ${targetRoom}\n`);
    
    // Forward answer to caller
    io.to(targetRoom).emit('call:answer', {
      ...data,
      fromUserId: socket.userId
    });
    
    process.stdout.write(`✅✅✅ Answer forwarded\n\n`);
  });

  socket.on('call:ice-candidate', (data) => {
    // Forward ICE candidate with detailed logging
    const candidateString = data.candidate?.candidate || '';
    const candidateType = candidateString.includes('typ relay') ? 'relay' : 
                          candidateString.includes('typ srflx') ? 'srflx' :
                          candidateString.includes('typ host') ? 'host' : 'unknown';
    
    console.log('🧊 ICE candidate received:', {
      from: socket.userId,
      to: data.targetUserId,
      type: candidateType,
      candidate: candidateString.substring(0, 50)
    });
    
    const targetRoom = `user:${data.targetUserId}`;
    const roomExists = io.sockets.adapter.rooms.has(targetRoom);
    
    if (!roomExists) {
      console.warn(`⚠️  ICE candidate target room not found: ${targetRoom}`);
      return;
    }
    
    // Forward ICE candidate
    io.to(targetRoom).emit('call:ice-candidate', {
      ...data,
      fromUserId: socket.userId
    });
    
    console.log(`✅ ICE candidate forwarded to ${targetRoom} (type: ${candidateType})`);
  });

  socket.on('call:end', (data) => {
    console.log('Call end from:', socket.userId, 'to:', data.targetUserId);
    // Only parents can end calls (will be enforced by userRole check later)
    if (socket.userRole === 'parent') {
      socket.to(`user:${data.targetUserId}`).emit('call:end', {
        fromUserId: socket.userId
      });
    } else {
      socket.emit('error', { message: 'Only parents can end calls' });
    }
  });

  socket.on('call:cancel', (data) => {
    console.log('Call cancel from:', socket.userId, 'to:', data.targetUserId);
    // Forward cancel signal immediately (no role check needed for cancel)
    io.to(`user:${data.targetUserId}`).emit('call:cancel', {
      fromUserId: socket.userId
    });
  });

  socket.on('call:hangup', (data) => {
    console.log('Call hangup from:', socket.userId, 'to:', data.targetUserId);
    // Forward hangup signal immediately (no role check needed - permissions handled client-side)
    io.to(`user:${data.targetUserId}`).emit('call:hangup', {
      fromUserId: socket.userId
    });
  });

          // Join user room for targeted messaging
          socket.on('join:user-room', () => {
            if (socket.userId) {
              const room = `user:${socket.userId}`;
              socket.join(room);
              console.log('✅ User joined their room:', socket.userId, 'Room:', room);
              console.log('✅ Socket rooms after join:', Array.from(socket.rooms));

              // Emit confirmation back to client
              socket.emit('room:joined', { room, userId: socket.userId });

              // Log all active rooms for debugging
              setTimeout(() => {
                const allRooms = Array.from(io.sockets.adapter.rooms.keys());
                console.log('🏠 All active rooms:', allRooms);
                console.log('🏠 Rooms with user:', allRooms.filter(r => r.startsWith('user:')));
              }, 100);
            } else {
              console.warn('⚠️  join:user-room called but userId is missing');
            }
          });

  socket.on('disconnect', (reason) => {
    console.log('Socket disconnected:', socket.id, socket.userId, reason);
  });
});

server.listen(PORT, '0.0.0.0', () => {
  console.log(`✅✅✅ Signaling server listening on http://0.0.0.0:${PORT}`);
  console.log(`✅✅✅ Server is ready to accept connections`);
  console.log(`✅✅✅ Watching for child token connections...`);
  console.log(`✅✅✅ CORS configured for Vercel and HTTPS origins`);
}).on('error', (err: NodeJS.ErrnoException) => {
  console.error('❌❌❌ Server failed to start:', err);
  if (err.code === 'EADDRINUSE') {
    console.error(`❌ Port ${PORT} is already in use`);
  }
  process.exit(1);
});
