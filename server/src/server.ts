import 'dotenv/config';
import express from 'express';
import https from 'https';
import http from 'http';
import cors from 'cors';
import { Server as SocketIOServer } from 'socket.io';
import { AuthenticatedSocket } from './auth/socketAuth';
import fs from 'fs';
import path from 'path';
import firebaseAdmin from './config/firebase-admin';

const app = express();

// Try to create HTTPS server, fallback to HTTP
let server: http.Server | https.Server;
const useHttps = process.env.USE_HTTPS === 'true';

if (useHttps) {
  // Look for certificate files (generated by @vitejs/plugin-basic-ssl)
  const certPath = path.join(__dirname, '../../localhost.pem');
  const keyPath = path.join(__dirname, '../../localhost-key.pem');
  
  if (fs.existsSync(certPath) && fs.existsSync(keyPath)) {
    const cert = fs.readFileSync(certPath);
    const key = fs.readFileSync(keyPath);
    server = https.createServer({ cert, key }, app);
    console.log('🔒 HTTPS server enabled');
  } else {
    console.log('⚠️ HTTPS requested but certificates not found, using HTTP');
    server = http.createServer(app);
  }
} else {
  server = http.createServer(app);
}

const PORT = Number(process.env.PORT || 4000);
const CLIENT_ORIGIN = process.env.CLIENT_ORIGIN || 'http://localhost:5173';

console.log('🚀 Starting server...');
console.log('📋 Environment variables:');
console.log('  - PORT:', PORT);
console.log('  - CLIENT_ORIGIN:', CLIENT_ORIGIN);
console.log('  - NODE_ENV:', process.env.NODE_ENV || 'development');

// Allow multiple origins for local network access (both HTTP and HTTPS)
// Also allow Vercel deployments and custom domains
const allowedOrigins = [
  CLIENT_ORIGIN,
  'http://localhost:5173',
  'https://localhost:5173',
  'http://127.0.0.1:5173',
  'https://127.0.0.1:5173',
  'http://192.168.0.166:5173',
  'https://192.168.0.166:5173',
  'http://10.150.157.142:5173',
  'https://10.150.157.142:5173',
  // Allow any local network IP (both HTTP and HTTPS)
  /^https?:\/\/192\.168\.\d+\.\d+:5173$/,
  /^https?:\/\/10\.\d+\.\d+\.\d+:5173$/,
  // Allow Vercel deployments (any .vercel.app domain)
  /^https:\/\/.*\.vercel\.app$/,
  // Allow any HTTPS origin for production (more permissive for deployment)
  /^https:\/\/.*$/,
];

app.use(cors({ 
  origin: (origin, callback) => {
    // Allow requests with no origin (like mobile apps or curl requests)
    if (!origin) {
      console.log('✅ CORS: Allowing request with no origin');
      return callback(null, true);
    }
    
    console.log('🔍 CORS: Checking origin:', origin);
    
    // Check if origin is in allowed list
    const isAllowed = allowedOrigins.some(allowed => {
      if (typeof allowed === 'string') {
        return allowed === origin;
      } else if (allowed instanceof RegExp) {
        return allowed.test(origin);
      }
      return false;
    });
    
    if (isAllowed) {
      console.log('✅ CORS: Allowing origin:', origin);
      callback(null, true);
    } else {
      console.log('⚠️ CORS: Origin not in allowed list, but allowing anyway:', origin);
      callback(null, true); // Allow anyway for development/production flexibility
    }
  },
  credentials: true
}));
app.use(express.json());

app.get('/health', (_req, res) => {
  res.json({ ok: true, service: 'signaling-server' });
});

// Store FCM tokens per user
const fcmTokens = new Map<string, string>();

// Endpoint to store FCM token
app.post('/api/fcm-token', (req, res) => {
  try {
    const { userId, fcmToken } = req.body;
    
    if (!userId || !fcmToken) {
      return res.status(400).json({ error: 'userId and fcmToken are required' });
    }
    
    fcmTokens.set(userId, fcmToken);
    console.log(`✅ FCM token stored for user: ${userId}`);
    console.log(`📱 Token: ${fcmToken.substring(0, 20)}...`);
    
    res.json({ success: true });
  } catch (error) {
    console.error('❌ Error storing FCM token:', error);
    res.status(500).json({ error: 'Failed to store FCM token' });
  }
});

// Helper function to send FCM push notification
async function sendFCMPush(userId: string, title: string, body: string, data: any): Promise<void> {
  try {
    const fcmToken = fcmTokens.get(userId);
    if (!fcmToken) {
      console.log(`⚠️ No FCM token found for user: ${userId}`);
      return;
    }
    
    if (!firebaseAdmin) {
      console.warn('⚠️ Firebase Admin not initialized, cannot send push notification');
      return;
    }
    
    const message = {
      notification: {
        title,
        body
      },
      data: {
        ...data,
        click_action: 'FLUTTER_NOTIFICATION_CLICK'
      },
      token: fcmToken,
      webpush: {
        notification: {
          title,
          body,
          icon: '/icon-192.png',
          badge: '/icon-96.png',
          requireInteraction: true,
          vibrate: [200, 100, 200, 100, 200]
        },
        fcmOptions: {
          link: '/'
        }
      }
    };
    
    const response = await firebaseAdmin.messaging().send(message);
    console.log(`✅ FCM push notification sent successfully: ${response}`);
  } catch (error) {
    console.error(`❌ Error sending FCM push notification to ${userId}:`, error);
    if (error instanceof Error) {
      console.error('Error message:', error.message);
    }
  }
}

const io = new SocketIOServer(server, {
  cors: {
    origin: (origin, callback) => {
      // Allow requests with no origin
      if (!origin) {
        console.log('✅ Socket.IO CORS: Allowing request with no origin');
        return callback(null, true);
      }
      
      console.log('🔍 Socket.IO CORS: Checking origin:', origin);
      
      // Check if origin is in allowed list
      const isAllowed = allowedOrigins.some(allowed => {
        if (typeof allowed === 'string') {
          return allowed === origin;
        } else if (allowed instanceof RegExp) {
          return allowed.test(origin);
        }
        return false;
      });
      
      if (isAllowed) {
        console.log('✅ Socket.IO CORS: Allowing origin:', origin);
        callback(null, true);
      } else {
        console.log('⚠️ Socket.IO CORS: Origin not in allowed list, but allowing anyway:', origin);
        callback(null, true); // Allow anyway for development/production flexibility
      }
    },
    methods: ['GET', 'POST'],
    credentials: true
  },
  transports: ['websocket', 'polling'] // Allow both transports
});

// Authentication middleware DISABLED - using event-based auth instead
// io.use(async (socket: AuthenticatedSocket, next) => {
//   ... middleware code disabled ...
// });

io.on('connection', (socket: AuthenticatedSocket) => {
  console.log('🔌🔌🔌 NEW SOCKET CONNECTION (unauthenticated):', socket.id);
  
  // Set up 5 second auth timeout
  const authTimeout = setTimeout(() => {
    if (!socket.userId) {
      console.log(`⏰⏰⏰ Auth timeout for socket ${socket.id} - disconnecting`);
      socket.emit('auth:error', { message: 'Authentication timeout' });
      socket.disconnect();
    }
  }, 5000);
  
  // Event-based authentication handler
  socket.on('auth:join', async (data: { token: string }) => {
    console.log('🔐🔐🔐 AUTH:JOIN received from socket:', socket.id);
    console.log('🔐 Token:', data.token ? data.token.substring(0, 50) + '...' : 'UNDEFINED');
    
    const token = data.token;
    
    if (!token || typeof token !== 'string') {
      console.log('❌❌❌ Invalid token format');
      socket.emit('auth:error', { message: 'Invalid token format' });
      clearTimeout(authTimeout);
      socket.disconnect();
      return;
    }
    
    // Handle child tokens
    if (token.startsWith('child-token-')) {
      const userId = token.replace('child-token-', '').trim();
      console.log('🔐🔐🔐 Child token detected, userId:', userId);
      
      if (userId && userId.length > 0) {
        socket.userId = userId;
        socket.userRole = 'child';
        clearTimeout(authTimeout);
        
        // Join user room immediately
        const room = `user:${userId}`;
        socket.join(room);
        console.log('✅✅✅✅✅✅✅✅✅ CHILD ACCEPTED:', socket.id, 'User:', userId, 'Room:', room);
        
        socket.emit('auth:ok', { userId, role: 'child' });
        socket.emit('room:joined', { room, userId });
        
        // Log all rooms after join
        setTimeout(() => {
          const allRooms = Array.from(io.sockets.adapter.rooms.keys());
          console.log('📋 Rooms after child auth:', allRooms);
        }, 100);
        return;
      } else {
        console.log('❌❌❌ Child token has empty userId');
        socket.emit('auth:error', { message: 'Invalid child token' });
        clearTimeout(authTimeout);
        socket.disconnect();
        return;
      }
    }
    
    // Handle dev parent tokens (DEV only)
    if (
      process.env.NODE_ENV !== 'production' &&
      process.env.DEV_FAKE_PARENT_AUTH === 'true' &&
      token.startsWith('dev-parent-token-')
    ) {
      const userId = token.replace('dev-parent-token-', '').trim();
      if (userId && userId.length > 0) {
        socket.userId = userId;
        socket.userRole = 'parent';
        clearTimeout(authTimeout);
        
        const room = `user:${userId}`;
        socket.join(room);
        console.log('✅✅✅ DEV PARENT ACCEPTED:', socket.id, 'User:', userId);
        
        socket.emit('auth:ok', { userId, role: 'parent' });
        socket.emit('room:joined', { room, userId });
        return;
      }
    }
    
    // Handle Firebase tokens (parents)
    try {
      console.log('🔐🔐🔐 Verifying Firebase token...');
      const { verifyIdToken } = await import('./config/firebase-admin');
      const decodedToken = await verifyIdToken(token);
      
      socket.userId = decodedToken.uid;
      socket.userRole = 'parent';
      if (decodedToken.email) {
        socket.email = decodedToken.email;
      }
      
      clearTimeout(authTimeout);
      
      const room = `user:${socket.userId}`;
      socket.join(room);
      console.log('✅✅✅ PARENT AUTH SUCCESS:', socket.id, 'User:', socket.userId, 'Room:', room);
      
      socket.emit('auth:ok', { userId: socket.userId, role: 'parent' });
      socket.emit('room:joined', { room, userId: socket.userId });
      
      setTimeout(() => {
        const allRooms = Array.from(io.sockets.adapter.rooms.keys());
        console.log('📋 Rooms after parent auth:', allRooms);
      }, 100);
    } catch (error) {
      console.log('❌❌❌ Firebase auth exception:', error);
      socket.emit('auth:error', { message: 'Authentication failed' });
      clearTimeout(authTimeout);
      socket.disconnect();
    }
  });
  
  // Log all rooms immediately after connection
  setTimeout(() => {
    const allRooms = Array.from(io.sockets.adapter.rooms.keys());
    console.log('📋 Rooms after connection:', allRooms);
  }, 1000);

  // Helper function to check if socket is authenticated
  const requireAuth = (handler: () => void) => {
    if (!socket.userId) {
      console.warn('⚠️ Unauthenticated socket attempted to use protected event:', socket.id);
      socket.emit('auth:error', { message: 'Authentication required' });
      return;
    }
    handler();
  };

  // Ping/pong test (protected)
  socket.on('ping', (payload) => {
    requireAuth(() => {
      console.log('ping from authenticated client:', socket.userId, payload);
      socket.emit('pong', { at: Date.now(), userId: socket.userId });
    });
  });

  // WebRTC signaling events (protected)
  socket.on('call:offer', (data) => {
    requireAuth(() => {
    process.stdout.write('\n\n📞📞📞 ========== CALL OFFER RECEIVED ==========\n');
    process.stdout.write(`📞 From: ${socket.userId} (socket: ${socket.id})\n`);
    process.stdout.write(`📞 To: ${data.targetUserId}\n`);
    process.stdout.write(`📞 Has offer: ${!!data.offer}\n`);
    
    // Check if target user is in their room
    const targetRoom = `user:${data.targetUserId}`;
    const roomExists = io.sockets.adapter.rooms.has(targetRoom);
    
    process.stdout.write(`🔍 Target room: ${targetRoom}\n`);
    process.stdout.write(`🔍 Room exists: ${roomExists}\n`);
    
    // Debug: List all rooms
    const allRooms = Array.from(io.sockets.adapter.rooms.keys());
    process.stdout.write(`📋 All active rooms: ${allRooms.join(', ')}\n`);
    
    // Also check all connected sockets and their userIds
    const connectedSockets = Array.from(io.sockets.sockets.values());
    process.stdout.write(`👥 Connected sockets (${connectedSockets.length}):\n`);
    connectedSockets.forEach(s => {
      const authSocket = s as AuthenticatedSocket;
      const isInRoom = Array.from(io.sockets.adapter.socketRooms(authSocket.id) || []).includes(targetRoom);
      process.stdout.write(`  - Socket ${authSocket.id}: userId=${authSocket.userId}, inRoom=${isInRoom}\n`);
    });
    
    if (!roomExists) {
      process.stdout.write(`❌❌❌ Target user NOT in room: ${targetRoom}\n`);
      socket.emit('error', { 
        message: `Gebruiker ${data.targetUserId} is niet online of niet verbonden.` 
      });
      return;
    }
    
          // Forward offer to target user
          const offerData = {
            ...data,
            fromUserId: socket.userId,
            targetUserId: data.targetUserId
          };
          
          process.stdout.write(`📤📤📤 Forwarding offer to room: ${targetRoom}\n`);
          process.stdout.write(`📤 Sending to socket in room: ${targetRoom}\n`);
          process.stdout.write(`📤 Offer data: ${JSON.stringify({
            fromUserId: offerData.fromUserId,
            targetUserId: offerData.targetUserId,
            hasOffer: !!offerData.offer,
            offerType: offerData.offer?.type
          })}\n`);
          
          // Use io.to() instead of socket.to() to ensure it reaches the room
          io.to(targetRoom).emit('call:offer', offerData);
          
          // Also log how many sockets are in the target room
          const socketsInRoom = io.sockets.adapter.rooms.get(targetRoom);
          const socketCount = socketsInRoom ? socketsInRoom.size : 0;
          process.stdout.write(`📤 Sockets in room: ${socketCount}\n`);
          
          // Send FCM push notification if target user is not connected via socket
          if (socketCount === 0) {
            process.stdout.write(`📱 No active socket connection, sending FCM push notification...\n`);
            sendFCMPush(
              data.targetUserId,
              'Nieuwe oproep',
              'Je hebt een oproep ontvangen',
              {
                type: 'call:offer',
                fromUserId: socket.userId || '',
                targetUserId: data.targetUserId,
                callId: `call-${Date.now()}`
              }
            ).catch(err => {
              console.error('❌ Failed to send FCM push:', err);
            });
          }
          
          process.stdout.write(`✅✅✅ Call offer forwarded to: ${targetRoom}\n\n`);
    });
  });

  socket.on('call:answer', (data) => {
    requireAuth(() => {
    process.stdout.write('\n\n📞📞📞 ========== CALL ANSWER RECEIVED ==========\n');
    process.stdout.write(`📞 From: ${socket.userId} (socket: ${socket.id})\n`);
    process.stdout.write(`📞 To: ${data.targetUserId}\n`);
    process.stdout.write(`📞 Has answer: ${!!data.answer}\n`);
    
    const targetRoom = `user:${data.targetUserId}`;
    process.stdout.write(`📤 Forwarding answer to room: ${targetRoom}\n`);
    
    // Forward answer to caller
    io.to(targetRoom).emit('call:answer', {
      ...data,
      fromUserId: socket.userId
    });
    
    process.stdout.write(`✅✅✅ Answer forwarded\n\n`);
    });
  });

  socket.on('call:ice-candidate', (data) => {
    requireAuth(() => {
    // Forward ICE candidate with detailed logging
    const candidateString = data.candidate?.candidate || '';
    const candidateType = candidateString.includes('typ relay') ? 'relay' : 
                          candidateString.includes('typ srflx') ? 'srflx' :
                          candidateString.includes('typ host') ? 'host' : 'unknown';
    
    console.log('🧊 ICE candidate received:', {
      from: socket.userId,
      to: data.targetUserId,
      type: candidateType,
      candidate: candidateString.substring(0, 50)
    });
    
    const targetRoom = `user:${data.targetUserId}`;
    const roomExists = io.sockets.adapter.rooms.has(targetRoom);
    
    if (!roomExists) {
      console.warn(`⚠️  ICE candidate target room not found: ${targetRoom}`);
      return;
    }
    
    // Forward ICE candidate
    io.to(targetRoom).emit('call:ice-candidate', {
      ...data,
      fromUserId: socket.userId
    });
    
    console.log(`✅ ICE candidate forwarded to ${targetRoom} (type: ${candidateType})`);
    });
  });

  socket.on('call:end', (data) => {
    requireAuth(() => {
    console.log('Call end from:', socket.userId, 'to:', data.targetUserId);
    // Only parents can end calls (will be enforced by userRole check later)
    if (socket.userRole === 'parent') {
      socket.to(`user:${data.targetUserId}`).emit('call:end', {
        fromUserId: socket.userId
      });
    } else {
      socket.emit('error', { message: 'Only parents can end calls' });
    }
    });
  });

  socket.on('call:cancel', (data) => {
    requireAuth(() => {
    console.log('Call cancel from:', socket.userId, 'to:', data.targetUserId);
    // Forward cancel signal immediately (no role check needed for cancel)
    io.to(`user:${data.targetUserId}`).emit('call:cancel', {
      fromUserId: socket.userId
    });
    });
  });

  socket.on('call:hangup', (data) => {
    requireAuth(() => {
    console.log('Call hangup from:', socket.userId, 'to:', data.targetUserId);
    // Forward hangup signal immediately (no role check needed - permissions handled client-side)
    io.to(`user:${data.targetUserId}`).emit('call:hangup', {
      fromUserId: socket.userId
    });
    });
  });

  // Join user room (protected - but should already be joined after auth)
  socket.on('join:user-room', () => {
    requireAuth(() => {
      if (socket.userId) {
        const room = `user:${socket.userId}`;
        socket.join(room);
        console.log('✅ User joined their room:', socket.userId, 'Room:', room);
        console.log('✅ Socket rooms after join:', Array.from(socket.rooms));

        // Emit confirmation back to client
        socket.emit('room:joined', { room, userId: socket.userId });

        // Log all active rooms for debugging
        setTimeout(() => {
          const allRooms = Array.from(io.sockets.adapter.rooms.keys());
          console.log('🏠 All active rooms:', allRooms);
          console.log('🏠 Rooms with user:', allRooms.filter(r => r.startsWith('user:')));
        }, 100);
      } else {
        console.warn('⚠️  join:user-room called but userId is missing');
      }
    });
  });

  socket.on('disconnect', (reason) => {
    console.log('Socket disconnected:', socket.id, socket.userId, reason);
  });
});

server.listen(PORT, '0.0.0.0', () => {
  console.log(`✅✅✅ Signaling server listening on http://0.0.0.0:${PORT}`);
  console.log(`✅✅✅ Server is ready to accept connections`);
  console.log(`✅✅✅ Watching for child token connections...`);
  console.log(`✅✅✅ CORS configured for Vercel and HTTPS origins`);
}).on('error', (err: NodeJS.ErrnoException) => {
  console.error('❌❌❌ Server failed to start:', err);
  if (err.code === 'EADDRINUSE') {
    console.error(`❌ Port ${PORT} is already in use`);
  }
  process.exit(1);
});
