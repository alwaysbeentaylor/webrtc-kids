"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
require("dotenv/config");
const express_1 = __importDefault(require("express"));
const https_1 = __importDefault(require("https"));
const http_1 = __importDefault(require("http"));
const cors_1 = __importDefault(require("cors"));
const socket_io_1 = require("socket.io");
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const firebase_admin_1 = __importDefault(require("./config/firebase-admin"));
const app = (0, express_1.default)();
// Try to create HTTPS server, fallback to HTTP
let server;
const useHttps = process.env.USE_HTTPS === 'true';
if (useHttps) {
    // Look for certificate files (generated by @vitejs/plugin-basic-ssl)
    const certPath = path_1.default.join(__dirname, '../../localhost.pem');
    const keyPath = path_1.default.join(__dirname, '../../localhost-key.pem');
    if (fs_1.default.existsSync(certPath) && fs_1.default.existsSync(keyPath)) {
        const cert = fs_1.default.readFileSync(certPath);
        const key = fs_1.default.readFileSync(keyPath);
        server = https_1.default.createServer({ cert, key }, app);
        console.log('üîí HTTPS server enabled');
    }
    else {
        console.log('‚ö†Ô∏è HTTPS requested but certificates not found, using HTTP');
        server = http_1.default.createServer(app);
    }
}
else {
    server = http_1.default.createServer(app);
}
const PORT = Number(process.env.PORT || 4000);
const CLIENT_ORIGIN = process.env.CLIENT_ORIGIN || 'http://localhost:5173';
console.log('üöÄ Starting server...');
console.log('üìã Environment variables:');
console.log('  - PORT:', PORT);
console.log('  - CLIENT_ORIGIN:', CLIENT_ORIGIN);
console.log('  - NODE_ENV:', process.env.NODE_ENV || 'development');
// Allow multiple origins for local network access (both HTTP and HTTPS)
// Also allow Vercel deployments and custom domains
const allowedOrigins = [
    CLIENT_ORIGIN,
    'http://localhost:5173',
    'https://localhost:5173',
    'http://127.0.0.1:5173',
    'https://127.0.0.1:5173',
    'http://192.168.0.166:5173',
    'https://192.168.0.166:5173',
    'http://10.150.157.142:5173',
    'https://10.150.157.142:5173',
    // Allow any local network IP (both HTTP and HTTPS)
    /^https?:\/\/192\.168\.\d+\.\d+:5173$/,
    /^https?:\/\/10\.\d+\.\d+\.\d+:5173$/,
    // Allow Vercel deployments (any .vercel.app domain)
    /^https:\/\/.*\.vercel\.app$/,
    // Allow any HTTPS origin for production (more permissive for deployment)
    /^https:\/\/.*$/,
];
app.use((0, cors_1.default)({
    origin: (origin, callback) => {
        // Allow requests with no origin (like mobile apps or curl requests)
        if (!origin) {
            console.log('‚úÖ CORS: Allowing request with no origin');
            return callback(null, true);
        }
        console.log('üîç CORS: Checking origin:', origin);
        // Check if origin is in allowed list
        const isAllowed = allowedOrigins.some(allowed => {
            if (typeof allowed === 'string') {
                return allowed === origin;
            }
            else if (allowed instanceof RegExp) {
                return allowed.test(origin);
            }
            return false;
        });
        if (isAllowed) {
            console.log('‚úÖ CORS: Allowing origin:', origin);
            callback(null, true);
        }
        else {
            console.log('‚ö†Ô∏è CORS: Origin not in allowed list, but allowing anyway:', origin);
            callback(null, true); // Allow anyway for development/production flexibility
        }
    },
    credentials: true
}));
app.use(express_1.default.json());
app.get('/health', (_req, res) => {
    res.json({ ok: true, service: 'signaling-server' });
});
// Store FCM tokens per user
const fcmTokens = new Map();
// Endpoint to store FCM token
app.post('/api/fcm-token', (req, res) => {
    try {
        const { userId, fcmToken } = req.body;
        if (!userId || !fcmToken) {
            return res.status(400).json({ error: 'userId and fcmToken are required' });
        }
        fcmTokens.set(userId, fcmToken);
        console.log(`‚úÖ FCM token stored for user: ${userId}`);
        console.log(`üì± Token: ${fcmToken.substring(0, 20)}...`);
        res.json({ success: true });
    }
    catch (error) {
        console.error('‚ùå Error storing FCM token:', error);
        res.status(500).json({ error: 'Failed to store FCM token' });
    }
});
// Helper function to send FCM push notification
async function sendFCMPush(userId, title, body, data) {
    try {
        const fcmToken = fcmTokens.get(userId);
        if (!fcmToken) {
            console.log(`‚ö†Ô∏è No FCM token found for user: ${userId}`);
            return;
        }
        if (!firebase_admin_1.default) {
            console.warn('‚ö†Ô∏è Firebase Admin not initialized, cannot send push notification');
            return;
        }
        const message = {
            notification: {
                title,
                body
            },
            data: {
                ...data,
                click_action: 'FLUTTER_NOTIFICATION_CLICK'
            },
            token: fcmToken,
            webpush: {
                notification: {
                    title,
                    body,
                    icon: '/icon-192.png',
                    badge: '/icon-96.png',
                    requireInteraction: true,
                    vibrate: [200, 100, 200, 100, 200]
                },
                fcmOptions: {
                    link: '/'
                }
            }
        };
        const response = await firebase_admin_1.default.messaging().send(message);
        console.log(`‚úÖ FCM push notification sent successfully: ${response}`);
    }
    catch (error) {
        console.error(`‚ùå Error sending FCM push notification to ${userId}:`, error);
        if (error instanceof Error) {
            console.error('Error message:', error.message);
        }
    }
}
const io = new socket_io_1.Server(server, {
    cors: {
        origin: (origin, callback) => {
            // Allow requests with no origin
            if (!origin) {
                console.log('‚úÖ Socket.IO CORS: Allowing request with no origin');
                return callback(null, true);
            }
            console.log('üîç Socket.IO CORS: Checking origin:', origin);
            // Check if origin is in allowed list
            const isAllowed = allowedOrigins.some(allowed => {
                if (typeof allowed === 'string') {
                    return allowed === origin;
                }
                else if (allowed instanceof RegExp) {
                    return allowed.test(origin);
                }
                return false;
            });
            if (isAllowed) {
                console.log('‚úÖ Socket.IO CORS: Allowing origin:', origin);
                callback(null, true);
            }
            else {
                console.log('‚ö†Ô∏è Socket.IO CORS: Origin not in allowed list, but allowing anyway:', origin);
                callback(null, true); // Allow anyway for development/production flexibility
            }
        },
        methods: ['GET', 'POST'],
        credentials: true
    },
    transports: ['websocket', 'polling'] // Allow both transports
});
// Authentication middleware DISABLED - using event-based auth instead
// io.use(async (socket: AuthenticatedSocket, next) => {
//   ... middleware code disabled ...
// });
io.on('connection', (socket) => {
    console.log('üîåüîåüîå NEW SOCKET CONNECTION (unauthenticated):', socket.id);
    // Set up 5 second auth timeout
    const authTimeout = setTimeout(() => {
        if (!socket.userId) {
            console.log(`‚è∞‚è∞‚è∞ Auth timeout for socket ${socket.id} - disconnecting`);
            socket.emit('auth:error', { message: 'Authentication timeout' });
            socket.disconnect();
        }
    }, 5000);
    // Event-based authentication handler
    socket.on('auth:join', async (data) => {
        console.log('üîêüîêüîê AUTH:JOIN received from socket:', socket.id);
        console.log('üîê Token:', data.token ? data.token.substring(0, 50) + '...' : 'UNDEFINED');
        const token = data.token;
        if (!token || typeof token !== 'string') {
            console.log('‚ùå‚ùå‚ùå Invalid token format');
            socket.emit('auth:error', { message: 'Invalid token format' });
            clearTimeout(authTimeout);
            socket.disconnect();
            return;
        }
        // Handle child tokens
        if (token.startsWith('child-token-')) {
            const userId = token.replace('child-token-', '').trim();
            console.log('üîêüîêüîê Child token detected, userId:', userId);
            if (userId && userId.length > 0) {
                socket.userId = userId;
                socket.userRole = 'child';
                clearTimeout(authTimeout);
                // Join user room immediately
                const room = `user:${userId}`;
                socket.join(room);
                console.log('‚úÖ‚úÖ‚úÖ‚úÖ‚úÖ‚úÖ‚úÖ‚úÖ‚úÖ CHILD ACCEPTED:', socket.id, 'User:', userId, 'Room:', room);
                socket.emit('auth:ok', { userId, role: 'child' });
                socket.emit('room:joined', { room, userId });
                // Log all rooms after join
                setTimeout(() => {
                    const allRooms = Array.from(io.sockets.adapter.rooms.keys());
                    console.log('üìã Rooms after child auth:', allRooms);
                }, 100);
                return;
            }
            else {
                console.log('‚ùå‚ùå‚ùå Child token has empty userId');
                socket.emit('auth:error', { message: 'Invalid child token' });
                clearTimeout(authTimeout);
                socket.disconnect();
                return;
            }
        }
        // Handle dev parent tokens (DEV only)
        if (process.env.NODE_ENV !== 'production' &&
            process.env.DEV_FAKE_PARENT_AUTH === 'true' &&
            token.startsWith('dev-parent-token-')) {
            const userId = token.replace('dev-parent-token-', '').trim();
            if (userId && userId.length > 0) {
                socket.userId = userId;
                socket.userRole = 'parent';
                clearTimeout(authTimeout);
                const room = `user:${userId}`;
                socket.join(room);
                console.log('‚úÖ‚úÖ‚úÖ DEV PARENT ACCEPTED:', socket.id, 'User:', userId);
                socket.emit('auth:ok', { userId, role: 'parent' });
                socket.emit('room:joined', { room, userId });
                return;
            }
        }
        // Handle Firebase tokens (parents)
        try {
            console.log('üîêüîêüîê Verifying Firebase token...');
            const { verifyIdToken } = await Promise.resolve().then(() => __importStar(require('./config/firebase-admin')));
            const decodedToken = await verifyIdToken(token);
            socket.userId = decodedToken.uid;
            socket.userRole = 'parent';
            if (decodedToken.email) {
                socket.email = decodedToken.email;
            }
            clearTimeout(authTimeout);
            const room = `user:${socket.userId}`;
            socket.join(room);
            console.log('‚úÖ‚úÖ‚úÖ PARENT AUTH SUCCESS:', socket.id, 'User:', socket.userId, 'Room:', room);
            socket.emit('auth:ok', { userId: socket.userId, role: 'parent' });
            socket.emit('room:joined', { room, userId: socket.userId });
            setTimeout(() => {
                const allRooms = Array.from(io.sockets.adapter.rooms.keys());
                console.log('üìã Rooms after parent auth:', allRooms);
            }, 100);
        }
        catch (error) {
            console.log('‚ùå‚ùå‚ùå Firebase auth exception:', error);
            socket.emit('auth:error', { message: 'Authentication failed' });
            clearTimeout(authTimeout);
            socket.disconnect();
        }
    });
    // Log all rooms immediately after connection
    setTimeout(() => {
        const allRooms = Array.from(io.sockets.adapter.rooms.keys());
        console.log('üìã Rooms after connection:', allRooms);
    }, 1000);
    // Helper function to check if socket is authenticated
    const requireAuth = (handler) => {
        if (!socket.userId) {
            console.warn('‚ö†Ô∏è Unauthenticated socket attempted to use protected event:', socket.id);
            socket.emit('auth:error', { message: 'Authentication required' });
            return;
        }
        handler();
    };
    // Ping/pong test (protected)
    socket.on('ping', (payload) => {
        requireAuth(() => {
            console.log('ping from authenticated client:', socket.userId, payload);
            socket.emit('pong', { at: Date.now(), userId: socket.userId });
        });
    });
    // WebRTC signaling events (protected)
    socket.on('call:offer', (data) => {
        requireAuth(() => {
            process.stdout.write('\n\nüìûüìûüìû ========== CALL OFFER RECEIVED ==========\n');
            process.stdout.write(`üìû From: ${socket.userId} (socket: ${socket.id})\n`);
            process.stdout.write(`üìû To: ${data.targetUserId}\n`);
            process.stdout.write(`üìû Has offer: ${!!data.offer}\n`);
            // Check if target user is in their room
            const targetRoom = `user:${data.targetUserId}`;
            const roomExists = io.sockets.adapter.rooms.has(targetRoom);
            process.stdout.write(`üîç Target room: ${targetRoom}\n`);
            process.stdout.write(`üîç Room exists: ${roomExists}\n`);
            // Debug: List all rooms
            const allRooms = Array.from(io.sockets.adapter.rooms.keys());
            process.stdout.write(`üìã All active rooms: ${allRooms.join(', ')}\n`);
            // Also check all connected sockets and their userIds
            const connectedSockets = Array.from(io.sockets.sockets.values());
            process.stdout.write(`üë• Connected sockets (${connectedSockets.length}):\n`);
            connectedSockets.forEach(s => {
                const authSocket = s;
                const isInRoom = Array.from(io.sockets.adapter.socketRooms(authSocket.id) || []).includes(targetRoom);
                process.stdout.write(`  - Socket ${authSocket.id}: userId=${authSocket.userId}, inRoom=${isInRoom}\n`);
            });
            if (!roomExists) {
                process.stdout.write(`‚ùå‚ùå‚ùå Target user NOT in room: ${targetRoom}\n`);
                socket.emit('error', {
                    message: `Gebruiker ${data.targetUserId} is niet online of niet verbonden.`
                });
                return;
            }
            // Forward offer to target user
            const offerData = {
                ...data,
                fromUserId: socket.userId,
                targetUserId: data.targetUserId
            };
            process.stdout.write(`üì§üì§üì§ Forwarding offer to room: ${targetRoom}\n`);
            process.stdout.write(`üì§ Sending to socket in room: ${targetRoom}\n`);
            process.stdout.write(`üì§ Offer data: ${JSON.stringify({
                fromUserId: offerData.fromUserId,
                targetUserId: offerData.targetUserId,
                hasOffer: !!offerData.offer,
                offerType: offerData.offer?.type
            })}\n`);
            // Use io.to() instead of socket.to() to ensure it reaches the room
            io.to(targetRoom).emit('call:offer', offerData);
            // Also log how many sockets are in the target room
            const socketsInRoom = io.sockets.adapter.rooms.get(targetRoom);
            const socketCount = socketsInRoom ? socketsInRoom.size : 0;
            process.stdout.write(`üì§ Sockets in room: ${socketCount}\n`);
            // Send FCM push notification if target user is not connected via socket
            if (socketCount === 0) {
                process.stdout.write(`üì± No active socket connection, sending FCM push notification...\n`);
                sendFCMPush(data.targetUserId, 'Nieuwe oproep', 'Je hebt een oproep ontvangen', {
                    type: 'call:offer',
                    fromUserId: socket.userId || '',
                    targetUserId: data.targetUserId,
                    callId: `call-${Date.now()}`
                }).catch(err => {
                    console.error('‚ùå Failed to send FCM push:', err);
                });
            }
            process.stdout.write(`‚úÖ‚úÖ‚úÖ Call offer forwarded to: ${targetRoom}\n\n`);
        });
    });
    socket.on('call:answer', (data) => {
        requireAuth(() => {
            process.stdout.write('\n\nüìûüìûüìû ========== CALL ANSWER RECEIVED ==========\n');
            process.stdout.write(`üìû From: ${socket.userId} (socket: ${socket.id})\n`);
            process.stdout.write(`üìû To: ${data.targetUserId}\n`);
            process.stdout.write(`üìû Has answer: ${!!data.answer}\n`);
            const targetRoom = `user:${data.targetUserId}`;
            process.stdout.write(`üì§ Forwarding answer to room: ${targetRoom}\n`);
            // Forward answer to caller
            io.to(targetRoom).emit('call:answer', {
                ...data,
                fromUserId: socket.userId
            });
            process.stdout.write(`‚úÖ‚úÖ‚úÖ Answer forwarded\n\n`);
        });
    });
    socket.on('call:ice-candidate', (data) => {
        requireAuth(() => {
            // Forward ICE candidate with detailed logging
            const candidateString = data.candidate?.candidate || '';
            const candidateType = candidateString.includes('typ relay') ? 'relay' :
                candidateString.includes('typ srflx') ? 'srflx' :
                    candidateString.includes('typ host') ? 'host' : 'unknown';
            console.log('üßä ICE candidate received:', {
                from: socket.userId,
                to: data.targetUserId,
                type: candidateType,
                candidate: candidateString.substring(0, 50)
            });
            const targetRoom = `user:${data.targetUserId}`;
            const roomExists = io.sockets.adapter.rooms.has(targetRoom);
            if (!roomExists) {
                console.warn(`‚ö†Ô∏è  ICE candidate target room not found: ${targetRoom}`);
                return;
            }
            // Forward ICE candidate
            io.to(targetRoom).emit('call:ice-candidate', {
                ...data,
                fromUserId: socket.userId
            });
            console.log(`‚úÖ ICE candidate forwarded to ${targetRoom} (type: ${candidateType})`);
        });
    });
    socket.on('call:end', (data) => {
        requireAuth(() => {
            console.log('Call end from:', socket.userId, 'to:', data.targetUserId);
            // Only parents can end calls (will be enforced by userRole check later)
            if (socket.userRole === 'parent') {
                socket.to(`user:${data.targetUserId}`).emit('call:end', {
                    fromUserId: socket.userId
                });
            }
            else {
                socket.emit('error', { message: 'Only parents can end calls' });
            }
        });
    });
    socket.on('call:cancel', (data) => {
        requireAuth(() => {
            console.log('Call cancel from:', socket.userId, 'to:', data.targetUserId);
            // Forward cancel signal immediately (no role check needed for cancel)
            io.to(`user:${data.targetUserId}`).emit('call:cancel', {
                fromUserId: socket.userId
            });
        });
    });
    socket.on('call:hangup', (data) => {
        requireAuth(() => {
            console.log('Call hangup from:', socket.userId, 'to:', data.targetUserId);
            // Forward hangup signal immediately (no role check needed - permissions handled client-side)
            io.to(`user:${data.targetUserId}`).emit('call:hangup', {
                fromUserId: socket.userId
            });
        });
    });
    // Join user room (protected - but should already be joined after auth)
    socket.on('join:user-room', () => {
        requireAuth(() => {
            if (socket.userId) {
                const room = `user:${socket.userId}`;
                socket.join(room);
                console.log('‚úÖ User joined their room:', socket.userId, 'Room:', room);
                console.log('‚úÖ Socket rooms after join:', Array.from(socket.rooms));
                // Emit confirmation back to client
                socket.emit('room:joined', { room, userId: socket.userId });
                // Log all active rooms for debugging
                setTimeout(() => {
                    const allRooms = Array.from(io.sockets.adapter.rooms.keys());
                    console.log('üè† All active rooms:', allRooms);
                    console.log('üè† Rooms with user:', allRooms.filter(r => r.startsWith('user:')));
                }, 100);
            }
            else {
                console.warn('‚ö†Ô∏è  join:user-room called but userId is missing');
            }
        });
    });
    socket.on('disconnect', (reason) => {
        console.log('Socket disconnected:', socket.id, socket.userId, reason);
    });
});
server.listen(PORT, '0.0.0.0', () => {
    console.log(`‚úÖ‚úÖ‚úÖ Signaling server listening on http://0.0.0.0:${PORT}`);
    console.log(`‚úÖ‚úÖ‚úÖ Server is ready to accept connections`);
    console.log(`‚úÖ‚úÖ‚úÖ Watching for child token connections...`);
    console.log(`‚úÖ‚úÖ‚úÖ CORS configured for Vercel and HTTPS origins`);
}).on('error', (err) => {
    console.error('‚ùå‚ùå‚ùå Server failed to start:', err);
    if (err.code === 'EADDRINUSE') {
        console.error(`‚ùå Port ${PORT} is already in use`);
    }
    process.exit(1);
});
//# sourceMappingURL=server.js.map